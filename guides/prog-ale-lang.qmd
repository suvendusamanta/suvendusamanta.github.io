---
title: Ale and Go
---

[Ale](https://www.ale-lang.org/) is a Lisp designed to be hosted in a Go process.  Use both the world of GO and Clojure <!--Add more description later-->

#### Ale is a LISP programming language ( Lips-1 vs Lisp-2 )
There are two kind of LISP languages based on if they uses seperate namespace for functoins. Lisp-a refers to Scheme's model uses single namespace. Lisp-2 uses Conmmon Lisp's model where the namespace for function names is separate from the namespace for data variables. 
Ale follows Lisp-1.

#### Charateristics of Ale
1. Lisp-1 : Lisp-1 are minimal. It's simpler than common lisp.
2. Does not support both interpretation and compiled operation. When the programmer performs an (eval), Ale immediately compiles the form and invokes its abstract machine. 
3. Bindings in Ale are immutable, even in namespaces. ( more functional than other LISP )
4. Syntax borroed from Scheme and Clojure.


### Why Ale
+ Use with Go 
    + Simple and minimally designed compiled language.

+ Overcome limitation of Go programming languages
    - Go is compiled language and provides no REPL for interactive development. <!-- ale REPL is not matured--> 
    - Go functions are very rigid ( no defalt parameters, oveloading of functions - useful for scientific computing).
    - Use functional style program over Go's imperative style
    - lazy evalation? <!--understand first-->

#### Production ready ?
According to the docs
1. Runtime is partially completed.
2. Compiler performs very little optimization
3. VM could be faster
4. Code generation could be more efficient
But deevelopment is very active as per github commits (https://github.com/kode4food/ale)

Still a work in progress. Use at your own risk. : need to develop few libraries to demonstrate the power.


## language

### Getting started
#### Prerequisite
1. Go programming language
2. Lisp ( especially Clojure )

#### Installation
1. Install Go first if it is not installed already.
2. Set GOPATH environment variable
3. Add `GOPATH/bin` in PATH to access `ale` command
3. Install Ale using `go install` command :
    ```{bash}
    go install github.com/kode4food/ale/cmd/ale@latest

    ```
4. Check typing `ale` command  

#### Use REPL with **ale** command <!-- It's CRUDE REPL w.r.t other Lisp or functional language ?? -->
```
$ale
Ale (A Lisp Environment) 0.1

  (help) Display this help message
  (doc form) Display documentation. Example: (doc go)
  (use ns) Change current namespace. Example: (use foo)
  (cls) Clear the screen
  (quit) Quit the REPL

  The prompt below identifies the current namespace, followed by the number of expressions that will have been
  evaluated in the current REPL session. A single expression can span multiple lines.

user [1]>

```

#### Run a source file 
1. Create a file 'somefile.ale'  
2. Use ale filename.ale to run the programm
```
ale somefile.ale
or 
cat somefile.ale | ale
```

#### Embed in a Go process
Most interesting usecase to leaverage Go.
<!--detail later -->


### Language overview
1. program structure
    - Expression
    - comments
    - bassic operations : addition, division, equal to(=), eval, >=, <= 
2. Binding value with a name - declare, define, let
3. Basic(atomic) data types
    + atomic?
4. Defining functions - define-lambda, lambda, partial, comp
5. control flow - cond, delay, false? if
6. Data collection - car, cdr, assoc,dissoc,  conj, dissoc, drop, empty?, get, last, list, list? map, mapped, partition, quote, range
7. Recor/object - object
7. Update collection in a functional stype (get new instead modify) :  
    apply, 
    filter,
    fold-left,
    juxt,
    reduce
8. lazy sequence - lazy, lazy0seq, counted? 
9. Sequence of forms(instructions)
10. Macros - define-macro, gensym
11. Concurrency - chan, future, generate, go, promoises?
12. Utility - current-time



## Items list in documentation
+ addition (+)
+ and
+ apply
+ assoc
+ atom?
+ begin
+ car
+ cdr
+ chan
+ comp
 concat
 cond
 conj
 cons
 counted?
 current-time
 declare
 define
 define-lambda
 define-macro
 delay
 dissoc
 division (/)
 drop
 empty?
 equal to (=)
 eval
 false?
 filter
 fold-left
 future
 generate
 gensym
 get
 go
 greater or equal (>=)
 greater-than (>)
 identical (eq)
 if
 indexed?
 juxt
 keyword?
 lambda
 last
 lazy
 lazy-seq
 length
 less or equal (<=)
 less-than (<)
 let
 list
 list?
 map
 mapped?
 multiplication (*)
 not
 not equal to (!=)
 nth
 null?
 object
 object?
 or
 partial
 partition
 promise?
 quote
 range
 read
 reduce
 remainder (mod)
 seq
 seq->list
 seq->object
 seq->vector
 seq?
 some first (some->)
 some last (some->>)
 str
 str?
 subtraction (-)
 sym
 take
 thread first (->)
 thread last (->>)
 true?
 try/catch
 vector
 vector?
 when
 zero?